# Функции в С++

## Аргументы и параметры функции

```c++
void foo(int x, int y) // x, y - принимаемые параметры функции
{
}
 
foo(4, 5);  // 4, 5 - передаваемые аргументы функции
```


# Ссылки
```c++
T x;
T &rx = x; // rx это ссылка на x

```

```c++
void addOne(int &x) // x - это переменная-ссылка
{
    x = x + 1;
}
 
void main()
{
    int a = 7;
    std::cout << "a = " << a << '\n';   // 7
    addOne(a);
    std::cout << "a = " << a << '\n';   // 8
}
```

### Передача по константной ссылке
```c++
void boo(const int &y) // y - это константная ссылка
{
    y = 8; // ошибка компиляции: константная ссылка не может изменить свое же значение!
}
```
Правило: При передаче аргументов по ссылке всегда используйте константные ссылки,
если вам не нужно, чтобы функция изменяла значения аргументов.

# Указатели
& унарный оператор, показывает что речь идет про *АДРЕС*.
```c++
int x = 17;
int *p = &x;  // p - указатель, он содержит в себе адрес.
```

### Передача по адресу
Передача аргументов по адресу — это передача _копии_ адреса переменной-аргумента (а не исходной переменной). 
Поскольку аргумент является адресом, то параметром функции должен быть указатель.
Затем функция сможет разыменовать этот указатель для доступа или изменения исходного значения. 

```c++
#include <iostream>

void boo(int *ptr)
{
    std::cout << "ptr = " << ptr << '\n';     // 0x889efff80c  
    // - указатель на ячейку памяти (копия указателя на value)
    std::cout << "*ptr = " << *ptr << '\n';   // 4
    // - значение в ячейке памяти (разыменование)
    std::cout << "&ptr = " << &ptr << '\n';   // 0x889efff7e0  
    // - указатель на указатель
}

int main()
{
    int value = 4;
    boo(&value);
    return 0;
}
```

Передачу по адресу обычно используют с указателями на обычные массивы.
```c++
void printArray(int *array, int length)
{
    if (!array)
        return;
 
    for (int index=0; index < length; ++index)
        std::cout << array[index] << ' ';
}
 
int main()
{
    int array[3] = { 1, 2 , 3 };
    printArray(array, 3);
}
```


### Передача по константному адресу
```c++
void printArray(const int *array, int length)
{
    if (!array)
        return;
 
    for (int index=0; index < length; ++index)
        std::cout << array[index] << ' ';
}
```

### Возврат по значению
Возврат по значению — это самый простой и безопасный тип возврата. При возврате по значению,
копия возвращаемого значения передается обратно в caller.
```c++
int doubleValue(int a)
{
    int value = a * 3;
    return value; // копия value возвращается
} // value выходит из области видимости
```

### Возврат по адресу
Возврат по адресу — это возврат адреса переменной обратно в caller. 
Подобно передаче по адресу, возврат по адресу может возвращать только адрес переменной.

Возврат по адресу часто используется для возврата динамически выделенной памяти обратно в caller:
```c++
int* allocateArray(int size)
{
    return new int[size];
}
 
int main()
{
    int *array = allocateArray(20);

    delete[] array;
    return 0;
}
```

### Возврат по ссылке

При возврате по ссылке в caller возвращается ссылка на переменную. 
Затем caller может её использовать для продолжения изменения переменной, что может быть иногда полезно.

```c++
// Возвращаем ссылку на элемент массива по индексу index
int& getElement(std::array<int, 20> &array, int index)
{
    return array[index];
}
 
int main()
{
    std::array<int, 20> array;
 
    // Присваиваем элементу массива под индексом 15 значение 7
    getElement(array, 15) = 7;
	
    std::cout << array[15] << '\n';
 
    return 0;
}
```

В большинстве случаев идеальным вариантом для использования является возврат по значению. 
Это также самый гибкий и безопасный способ возврата данных обратно в вызывающий объект. 
Однако возврат по ссылке или по адресу также может быть полезен при работе с динамически выделенной памятью. 

При использовании возврата по ссылке или по адресу убедитесь, что вы не возвращаете ссылку или 
адрес локальной переменной, которая выйдет из области видимости, когда функция завершит свое выполнение!


## Оператор ->

```c++
struct LinkedListNode{
    LinkedListNode* next;
    int value;
}

int TakeNext(LinkedListNode* head, int n){
    while (n>0){
        head = head -> next; // Эквивалентно (*head).next
        --n;
    }
    return head->next;
}
```