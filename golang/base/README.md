# Базовый golang
> Дописать разные мелочи: TODO;

## Типы данных

### Целочисленные типы
- `int8`: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)

- `int16`: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)

- `int32`: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)

- `int64`: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)

- `uint8`: представляет целое число от 0 до 255 и занимает 1 байт

- `uint16`: представляет целое число от 0 до 65535 и занимает 2 байта

- `uint32`: представляет целое число от 0 до 4294967295 и занимает 4 байта

- `uint64`: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт

- `byte`: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт

- `rune`: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта

- `int`: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.

- `uint`: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.


```go
var a int8 = -1
var b uint8 = 2
var c byte = 3  // byte - синоним типа uint8
var d int16 = -4
```

### Числа с плавающей точкой
- `float32`: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)

- `float64`: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт.


```go
var f float32 = 18
var g float32 = 4.5
var d float64 = 0.23
```
### Комплексные числа
- `complex64`: комплексное число, где вещественная и мнимая части представляют числа float32

- `complex128`: комплексное число, где вещественная и мнимая части представляют числа float64


```go
var f complex64 = 1+2i
var g complex128 = 4+3i
```

### Тип bool
- Логический тип или тип `bool` может иметь одно из двух значений: true (истина) или false (ложь).



```go
var isAlive bool = true
var isEnabled bool = false
```

### Строки
- Строки представлены типом `string` и являются байтовым срезом имеющим произвольную длину.
> Строка - неизменяемый тип. Можно лишь получить новую строку.
> Нельзя изменить оперделенный символ в строке.

- Объявление типа:
```go
var name string = "asdasd"
```

- Отличие от других языков:
```go
test := "frйday"
fmt.Println(len(test)) // output: 7
```
Дело в том, что len измеряет строку по байтам, а не по символам.
Так же важно аккуратнее работать с индексированием строк (вызвав `string[5]` можно получить не то что ожидалось).
Лучше использовать `for` или `split`.

### Массивы
- Массивы `array` представляют последовательность элементов определенного типа и размера.
> Длинна массива не может быть изменена.

- Объявление типа:
```go
var a [5]int
b := [5]int{0, 0, 0, 0, 0}
c := []int{0, 0, 0, 0, 0}
d := [...]int{0, 0, 0, 0, 0} // размер устанавливается в зависимости от числа переданных элементов
```

### Срезы

- Срез - это массив с динамическим размером.
- Структура слайса:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
* Ёмкость(`cap`) - это выделенная память под элементы, при превышении размер автоматически увеличивается в два раза.
* Длина(`len`) - это инициализированная память элементов, для превышения(добавления) нужно вручную использовать
* `array` - это указатель на область памяти(массив)

Единственное отличие объявления среза от объявления массива — отсутствие указания длины в квадратных скобках и возможность создавать слайс через make().

```go
var a []float64
b := make([]float64, 5) // Срез создается встроенной функцией make:
c := make([]float64, 5, 10) //При этом будет создан обнуленный срез с длиной 5 и заранее выделенной емкостью в 10 элементов.

arr := [5]float64{1,2,3,4,5}
x := arr[0:5]
z := arr[0:5:10]
```

- Добавление в срез `append(slice []Type, value Type)`. Сложность `O(1)`.

```go
users := []string{"Tom", "Alice", "Kate"}
users = append(users, "Bob")
```

- Удаление элемента c помощью `append`. Сложность `O(N)`.

```go
slice = append(slice[:i], slice[i+1:]...)
```

#### Пример 1

```go
func main() {
    var array [10]int

    var slice = array[5:6]

    fmt.Println("length of slice: ", len(slice))
    fmt.Println("capacity of slice: ", cap(slice))
    fmt.Println(&slice[0] == &array[5])
}
```
output:
```go
length of slice:  1
capacity of slice:  5
true
```
Сapacity перенимается от начала среза внутри массива до его конца.
Адреса первого элемента среза и шестого элемента массива равны.

#### Пример 2
```go
func AddElement(slice []int, e int) []int {
    return append(slice, e)
}

func main() {
    var slice []int
    slice = append(slice, 1, 2, 3)

    newSlice := AddElement(slice, 4)
    fmt.Println("capasity = ", cap(newSlice))
}
```
output:

```go
capasity = 6
```

Если при добавлении элемента длина увеличивается на единицу и тем самым превышает заявленный объем, необходимо предоставить новый объем (в этом случае текущий объем обычно удваивается).

#### Пример 3
```go
    func AddElement(slice []int, e int) {
    slice = append(slice, e)
    slice[2] = 1
    fmt.Println(slice)
}

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    slice := arr[0:3:4]
    AddElement(slice, 4)
    fmt.Println(slice)
}

```
output:

```go
[1 2 1 4]
[1 2 1]

```
Так в функцию передается указатель на область данных - то меняя элементы среза внутри функции - вы меняете оригинал тоже.

Но добавление нового элемента - не изменит оригинал. Еще один пример будет ниже.

### Словарь

- Отображение `map` представляет ссылку на хеш-таблицу - структуру данных, где каждый элемент представляет пару "ключ-значение". Отображение определяется как объект типа `map[key]value`, где key представляет тип уникального ключа, а value - тип значения. Причем тип ключа key должен поддерживать операцию сравнения ==, чтобы оображение могло сопоставить значение с одним из ключей и хеш-таблицы.


```go
var people = map[string]int{
"Tom": 1,
"Bob": 2,
"Sam": 4,
"Alice": 8,
}
```


- Добавление и удаление элементов. Сложность `O(1)`.

```go
var people = map[string]int{ "Tom": 1, "Bob": 2}
people["Kate"] = 128
fmt.Println(people)     // map[Tom:1  Bob:2  Kate:128]

...
// Для удаления применяется встроенная функция delete(map, key), первым параметром которой является отображение,
// а вторым - ключ, по которому надо удалить элемент.
var people = map[string]int{ "Tom": 1, "Bob": 2, "Sam": 8}
delete(people, "Bob")
fmt.Println(people)     // map[Tom:1  Sam:8]
```

- При коллизиях мапа складывает в определенный bucket новое value (хитро выделяют битики)

> При передачи `map` или `slice` в другую область видимости - данные объекты копируются по значению, но т.к. у них внутри указатели то происходит конкретно копирование указателей, а не содержимого мапы/среза. т.е. при передаче по значению - можно изменять элементы внутри slice.array, т.к. указатель после копирования будет указывать на ту же область памяти что и исходный, но вот изменить длину(len) или вместимость(capasity) срезу уже не получится. Точнее эти изменения не будут видны снаружи вызываемой функции, т.к. длина, вместимость и (возможно) указатель array изменятся только в копии среза.

Пример:
```go
package main

import (
"fmt"
)

func f_slice_item(s []int) {
    s[0] = 1
}

func f_slice_size(s []int) {
    s = append(s, 1)
}

func f_slice_pointer_item(s *[]int) {
    (*s)[0] = 3
}

func f_slice_pointer_size(s *[]int) {
    *s = append(*s, 5)
}

func f_iter(s *[]int) {
    for i, v := range *s {
      fmt.Println(i, "-", v)
    }
}

func main() {
    var s []int

    fmt.Println("slice by value")
    s = []int{0}
    f_slice_item(s)
    fmt.Println(s)

    s = []int{0}
    f_slice_size(s)
    fmt.Println(s)

    fmt.Println()
    fmt.Println("slice by pointer")
    s = []int{0}
    f_slice_pointer_item(&s)
    fmt.Println(s)

    s = []int{0}
    f_slice_pointer_size(&s)
    fmt.Println(s)

    fmt.Println()
    fmt.Println("iter")
    f_iter(&s)
}
```

Результат выполнения:
```go
slice by value
[1]
[0]

slice by pointer
[3]
[0 5]

iter
0 - 0
1 - 5
```

Пример с map:
```go
func change_func(a map[string]string) {
    a["jopa"] = "popa"
}

func main() {
    a := map[string]string{}
    change_func(a)
    fmt.Println(a)
}
```

Результат выполнения:
```go
map[jopa:popa]
```