## Горутины

### Горутина 
— это функция, которая может работать параллельно с другими функциями в том же адресном пространстве.

Для создания горутины используется ключевое слово `go`, за которым следует вызов функции.
Пример: `go normalFunc(args...)` Функция `normalFunc(args...)` начнет выполняться асинхронно с вызвавшим ее кодом.

#### Сильные стороны горутин
- Плюс горутин в том, что горутины очень легковесны; (интересная статья на хабре про цифры)[https://habr.com/ru/post/135587/]. Практически все расходы — это создание стека, который очень невелик (это изменяемо, если нужно).
- Асинхронность.
- Если время выполнения функции достаточно велико и стоит нагрузить другие ядра.

#### Как можно использовать
```go
package main

// printer считывает сообщение из канала 'c', выводит его и засыпает на секунду
// pinger записывает в 'c' канал i-ые числа, пока printer спит

import (
    "fmt"
    "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- fmt.Sprintf("ping %v", i)
    }
}
func printer(c chan string) {
    for {
        msg := <-c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
        }
}
func main() {
    var c chan string = make(chan string)

    // Запуск двух горутин pinger и printer
    go pinger(c)
    go printer(c)

    var input string
    _, err := fmt.Scanln(&input)
    if err != nil {
        return
    }
}

```

#### Еще примеры
- [простой пример последовательного и одновременного выполнения](sequentiallyAndSimultaneously.go)

### Системные потоки

- В исходном коде (src/pkg/runtime/proc.c) приняты такие термины:
G (Goroutine) — Горутина
M (Machine) — Машина

- Каждая Машина работает в отдельном потоке и способна выполнять только одну Горутину в момент времени. 

- Планировщик операционной системы, в которой работает программа, переключает Машины. 
- Число работающих Машин ограничено переменной среды GOMAXPROCS или функцией `runtime.GOMAXPROCS(n int)`.
По умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер.

### Планировщик Go

- Цель планировщика (scheduler) в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M).
- Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out).
- Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). 
- Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
- Как только функция вновь готова к выполнению, она снова попадает в очередь.

![img.png](img.png)
