## Горутины

### Горутина 
— это функция, которая может работать параллельно с другими функциями в том же адресном пространстве.
Для создания горутины используется ключевое слово go, за которым следует вызов функции.

Пример: `go normalFunc(args...)` Функция `normalFunc(args...)` начнет выполняться асинхронно с вызвавшим ее кодом.

- Плюс горутин в том, что горутины очень легковесны. Практически все расходы — это создание стека, который очень невелик, хотя при необходимости может расти.
package main

```go
package main

import (
    "fmt"
    "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- fmt.Sprintf("ping %v", i)
    }
}
func printer(c chan string) {
    for {
        msg := <-c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
        }
}
func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go printer(c)

    var input string
    _, err := fmt.Scanln(&input)
    if err != nil {
        return
    }
}

```
### Системные потоки

- В исходном коде (src/pkg/runtime/proc.c) приняты такие термины:
G (Goroutine) — Горутина
M (Machine) — Машина

- Каждая Машина работает в отдельном потоке и способна выполнять только одну Горутину в момент времени. 

- Планировщик операционной системы, в которой работает программа, переключает Машины. 
- Число работающих Машин ограничено переменной среды GOMAXPROCS или функцией `runtime.GOMAXPROCS(n int)`.
По умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер.

### Планировщик Go

- Цель планировщика (scheduler) в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M).
- Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out).
- Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). 
- Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
- Как только функция вновь готова к выполнению, она снова попадает в очередь.

![img.png](img.png)