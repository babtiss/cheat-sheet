## Каналы
Это примитивы, которые беспечивают возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение.

> Структура канала TODO;

> Подробно под капотом TODO;

### Функции каналов

#### Создать канал
```go
var chanel chan int      // нулевое значение канала — это nil
chanel := make(chan int) // инициализируем
```

#### Запись в канал
```go
c <- data
```

#### Чтение из канала
```go
data = <- c
```

### Как работают каналы:
Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные.
Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные и возобновляет работу.

Горутина-отправитель может отправлять данные только в пустой канал.
Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.

#### Рассмотрим пример:
```go
package main
import "fmt"

func main() {

    intChanel := make(chan int)

    go func(){
        fmt.Println("Go routine starts")
        intChanel <- 5 // блокировка, пока данные не будут получены функцией main
        }()
    fmt.Println(<-intChanel) // получение данных из канала
    fmt.Println("The End")
}
```
Общий ход выполнения программы выглядит следующим образом:

- Запускается функция main. Она создает канал intChanel и запускает горутину в виде анонимной функции `go func()`.

- Функция `main` продолжает выполняться и блокируется на строке `fmt.Println(<-intChanel)`, пока не будут получены данные.

- Параллельно выполняется запущенная горутина в виде анонимной функции `go func()`. В конце своего выполнения она отправляет даные через канал: `intChanel <- 5`. Горутина блокируется, пока функция `main` не получит данные.

- Функция `main` получает отправленные данные, деблокируется и продолжает свою работу.

### Направление каналов
- Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим.
- Рассмотрим на примере [данной программы](https://github.com/babtiss/cheat-sheet/blob/master/golang/multithreading/goroutine/pingerAndPrinter.go)
Например, мы можем изменить функцию `pinger`:

```go
func pinger(c chan<- string)
```
и канал `c` будет только отправлять сообщение.
Попытка получить сообщение из канала c вызовет ошибку компилирования.

Также мы можем изменить функцию `printer` и канал `c` будет только принимать сообщение:

```go
func printer(c <-chan string)
```

- Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или отправляющие каналы.
Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!

- Запись в канал и чтение из канала блокирует и разблокирует выполнение горутин.
Например [данный код](deadlock.go) выполнится с ошибкой deadlock т.к. горутина main была заблокирована после записи в канал `message`
и не было горутин, которые бы прочитали сообщение из канала.

- Рекомендуется закрывать каналы, если вы закончили работу с ними.
[Пример](close.go). Чтение из канала так же возвращает информацию о том открыт канал или нет.
```go msg, open := <- message ```

### Буферизированный канал
Буферизированные каналы также создаются с помощью функции `make()`, только в качестве второго аргумента в функцию передается емкость канала.
Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.
Длина канала — это количество значений в очереди (не считанных) в буфере канала, емкость — это размер самого буфера канала.
При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.

#### Рассмотрим на примерах:

1. Место в канале еще не освободилось, а мы пытаемся туда записать элемент = deadlock!
```go
package main
import "fmt"

func main() {

    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    intCh <- 15  // блокировка - функция main ждет, когда освободится место в канале

    fmt.Println(<-intCh)
}
```

2.  Создается канал из трех элементов, и последовательно отправляются три значения типа int. Все корректно.
```go
package main
import "fmt"

func main() {

    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    fmt.Println(<-intCh)     // 10
    fmt.Println(<-intCh)     // 3
    fmt.Println(<-intCh)     //24
}
```

- С помощью встроенных функций cap() и len() можно получить соответственно емкость и количество элементов в канале.

#### Не стоит думать, что "Не буферизованный канал" == "Буферизованный канал с длиной буферизации = 1 элемент"

- Нет, в буферизованном блокировки на стороне пишущей горутины происходят в случае отсутствия свободного места в канале,
а в не буферизованном - пишущая горутина блокируется в ожидании когда данные из канала будут прочитаны читателем

```go
intCh := make(chan int)
intCh <- 10 // дедлок!
fmt.Println(<-intCh)


intCh := make(chan int, 1)
intCh <- 10
fmt.Println(<-intCh) // никаких дедлоков, всё ок


intCh := make(chan int, 1)
intCh <- 10
intCh <- 5 // дедлок, нет места под запись в канал
```

### Deadlock (Взаимная блокировка)
Как уже ранее говорилось, чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине.
Представим, что такие горутины отсутствуют, либо все горутины блокированы.
В этот момент возникает deadlock, который приведет к аварийному завершению программы.

#### Пример:
```go
package main

import "fmt"

func main() {
    fmt.Println("main() started")

    c := make(chan string)
    c <- "John"

    fmt.Println("main() stopped")
}
```

<details>
    <summary>Что выведет программа?</summary>

    main() started
    fatal error: all goroutines are asleep - deadlock!
    goroutine 1 [chan send]:
    main.main()
        program.go:10 +0xfd
    exit status 2

</details>

### Закрытие канала
В Go так же можно закрыть канал, через закрытый канал невозможно будет передать или принять данные.
Горутина может проверить закрыт канал или нет, используя следующую конструкцию:
`val, ok := <- channel`, где `ok` будет истиной в случае, если канал открыт или операция чтения может быть выполнена, иначе `ok` будет false, если канал закрыт и отсутствуют данных для чтения из него.
Закрыть канал можно, используя встроенную функцию close, используя следующий синтаксис `close(channel)`

#### Пример:
```go
package main

import "fmt"

func reader(c chan string) {
    <-c // for John
    <-c // for Mike
}

func main() {
    fmt.Println("main() started")

    c := make(chan string, 1)

    go reader(c)
    c <- "John"

    close(c) // closing channel

    c <- "Mike"
    fmt.Println("main() stopped")
}
```

<details>
    <summary>Что выведет программа?</summary>

    main() started
    panic: send on closed channel
    goroutine 1 [running]:
    main.main()
        program.go:20 +0x120
    exit status 2

</details>


#### Пример с циклом `for`
```go
package main

import "fmt"

func squares(c chan int) {
    for i := 0; i <= 9; i++ {
        c <- i * i
    }

    close(c) // close channel
}

func main() {
    fmt.Println("main() started")
    c := make(chan int)

    go squares(c) // start goroutine

    for val := range c {
        fmt.Println(val)
    }

    fmt.Println("main() stopped")
}
```

> Если вы не закроете канал для цикла `for` с использованием `range`, то программа будет завершена аварийно из-за `dealock` во время выполнения.
