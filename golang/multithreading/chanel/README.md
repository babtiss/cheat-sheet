## Каналы
Это примитивы, которые беспечивают возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение.
Пример создания канала:
```go
go chanel := make(chan string)
```

Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные.
Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные и возобновляет работу.

Горутина-отправитель может отправлять данные только в пустой канал.
Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.

#### Рассмотрим пример:
```go
package main
import "fmt"

func main() {

    intChanel := make(chan int)

    go func(){
        fmt.Println("Go routine starts")
        intChanel <- 5 // блокировка, пока данные не будут получены функцией main
        }()
    fmt.Println(<-intChanel) // получение данных из канала
    fmt.Println("The End")
}
```
Общий ход выполнения программы выглядит следующим образом:

- Запускается функция main. Она создает канал intChanel и запускает горутину в виде анонимной функции `go func()`.

- Функция `main` продолжает выполняться и блокируется на строке `fmt.Println(<-intChanel)`, пока не будут получены данные.

- Параллельно выполняется запущенная горутина в виде анонимной функции `go func()`. В конце своего выполнения она отправляет даные через канал: `intChanel <- 5`. Горутина блокируется, пока функция `main` не получит данные.

- Функция `main` получает отправленные данные, деблокируется и продолжает свою работу.

### Направление каналов
- Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим.
- Рассмотрим на примере [данной программы](https://github.com/babtiss/cheat-sheet/blob/master/golang/multithreading/goroutine/pingerAndPrinter.go)
Например, мы можем изменить функцию `pinger`:

```go
func pinger(c chan<- string)
```
и канал `c` будет только отправлять сообщение.
Попытка получить сообщение из канала c вызовет ошибку компилирования.

Также мы можем изменить функцию `printer` и канал `c` будет только принимать сообщение:

```go
func printer(c <-chan string)
```

- Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или отправляющие каналы.
Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!

- Запись в канал и чтение из канала блокирует и разблокирует выполнение горутин.
Например [данный код](deadlock.go) выполнится с ошибкой deadlock т.к. горутина main была заблокирована после записи в канал `message`
и не было горутин, которые бы прочитали сообщение из канала.

- Рекомендуется закрывать каналы, если вы закончили работу с ними.
[Пример](close.go). Чтение из канала так же возвращает информацию о том открыт канал или нет.
```go msg, open := <- message ```

### Буферизированный канал
Буферизированные каналы также создаются с помощью функции `make()`, только в качестве второго аргумента в функцию передается емкость канала.
Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.

При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.

#### Рассмотрим на примерах:

1. Место в канале еще не освободилось, а мы пытаемся туда записать элемент = deadlock!
```go
package main
import "fmt"

func main() {

    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    intCh <- 15  // блокировка - функция main ждет, когда освободится место в канале

    fmt.Println(<-intCh)
}
```

2.  Создается канал из трех элементов, и последовательно отправляются три значения типа int. Все корректно.
```go
package main
import "fmt"

func main() {

    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    fmt.Println(<-intCh)     // 10
    fmt.Println(<-intCh)     // 3
    fmt.Println(<-intCh)     //24
}
```

- С помощью встроенных функций cap() и len() можно получить соответственно емкость и количество элементов в канале.

#### Не стоит думать, что "Не буферизованный канал" == "Буферизованный канал с длиной буферизации = 1 элемент"

- Нет, в буферизованном блокировки на стороне пишущей горутины происходят в случае отсутствия свободного места в канале,
а в не буферизованном - пишущая горутина блокируется в ожидании когда данные из канала будут прочитаны читателем

```go
intCh := make(chan int)
intCh <- 10 // дедлок!
fmt.Println(<-intCh)


intCh := make(chan int, 1)
intCh <- 10
fmt.Println(<-intCh) // никаких дедлоков, всё ок


intCh := make(chan int, 1)
intCh <- 10
intCh <- 5 // дедлок, нет места под запись в канал
```

### SELECT
Оператор `select` позволяет go-процедуре находиться в ожидании нескольких операций передачи данных.
`select` блокируется до тех пор, пока один из его блоков case не будет готов к запуску, а затем выполняет этот блок.
Если сразу несколько блоков могут быть запущены, то выбирается произвольный.
Блок `default` в `select` запускается, если никакой другой блок не готов.

Рассмотрим работу оператора на примере:
```go
package main

import (
"fmt"
"time"
)

func main() {

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one second"
    }()
    go func() {
        time.Sleep(3 * time.Second)
        c2 <- "three second"
    }()

    for {
        select {
            case msg1 := <-c1:
                fmt.Println("received", msg1)
            case msg2 := <-c2:
                fmt.Println("received", msg2)
        }
    }
}
```
В таком случае мы получим последовательно строки:
```
received one second
received one second
received one second
received three second
received one second
received one second
received one second
received three second
...

```
Это происходит, потомучто одна горутина выполняет запись и чтение, пока другая спит.
