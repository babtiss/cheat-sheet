# Потокобезопасность

## Пакет sync

#### Гонка горутин иногда приводит к изменениям состояния любого значения, хранящегося в адресе памяти без какого-либо соблюдения порядка.

*Пример*
```go
package main

import (
    "fmt"
    "time"
)

type Counter struct {
    Count int
}

func updateC(c *Counter, cur int) {
    c.Count += cur
    fmt.Printf("New Count is %v\n", c.Count)
}

func main() {
    totalCur := 50
    c := Counter{1000000}
    for i := 0; i <= totalCur; i++ {
        go updateC(&c, int(i))
    }
    time.Sleep(time.Second * 1)  // this is just so that we don't need channels
}
```

output:
```go
New Count is 1001199
New Count is 1001030
New Count is 1001206
...
New Count is 1001176
New Count is 1000957
New Count is 1001005
```

> Как раз потомучто горутины обращались к области памяти безпорядочно мы и получаем такой несуразный результат


### `sync.Mutex` — Mutually Exclusive Lock.

```go
type Mutex struct {
    state int32
    sema  uint32
}
```

Он используется для того, чтобы он заблокировал остальные потоки и ждали в очереди, когда один поток (или горутина в случае Golang) обращается к значению внутри адреса памяти.
Это гарантирует, что не будет случайного доступа и изменения значений.

*Для примера выше*
```go
func updateC(c *Counter, cur int) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.Count += cur
    fmt.Printf("New Count is %v\n", c.Count)
}
// Достаточно замьютить содержимое функции, в которой происходит изменение значений
```

> Обязательно нужно использовать размьючивание `defer c.mu.Unlock()`. Причина этого в том, что нам нужно избежать взаимоблокировки.

Взаимоблокировки — это уязвимые места мьютексов, которых следует избегать.
Иначе блокировка будет реализована на неопределенный срок и что все остальные горутины вообще не смогут получить к ней доступ.

### `sync.RWMutex` - Reader and Writer Mutually Exclusive Lock.

Получаем дополнительный возможности:

- `Lock()`:  только одна процедура go читает/записывает одновременно, получая блокировку.
- `RLock()`: несколько подпрограмм могут читать (не записывать) одновременно, получая блокировку.

> В Python гигантский мьютекс висит над всем - что делает работу чуть тяжеловеснее. Тут по сути нам дали инструмент в свои руки.
