# Контекст (Context)

> Подробно под капотом + необычные кейсы и примеры использования: TODO;

Это объект, который предназначен в первую очередь для того, чтобы иметь возможность отменить извне выполнение потенциально долгой операции.
Кроме того, с помощью контекста можно хранить и передавать информацию между функциями и методами внутри вашей программы.

Отменять долгие операции с помощью контекста можно несколькими способами:

- По явному сигналу отмены `context.WithCancel`
- По истечению промежутка времени `context.WithTimeout`
- По наступлению временной отметки или дедлайна `context.WithDeadline`

## Подробнее о создании контекста

#### context.Background() ctx Context
Эта функция возвращает пустой контекст (правильно использовать на самых высоких уровнях программы)
```go
ctx, cancel := context.Background()
```

#### context.TODO() ctx Context
Эта функция также создает пустой контекст.
```go
ctx := context.TODO()
```

#### context.WithValue(parent Context, key, val interface{}) ctx Context
Эта функция принимает контекст и возвращает производный от него контекст, в котором значение `val` связано с `key` и проходит через всё контекстное дерево.
```go
ctx := context.WithValue(context.Background(), key, "test")
```

####  ctx.Value(key interface{}) val interface{}
Эта функция в данном контексте ищет значение 'val' по связному 'key'
```go
val := ctx.Value("myKey"))
```

#### context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)
Эта функция создает новый контекст из переданного ей родительского. Возвращается производный контекст и функция отмены. Вызывать функцию отмены контекста должна только та функция, которая его создает. Вы можете передавать функцию отмены другим функциям, если хотите, но это настоятельно не рекомендуется.

#### context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)
Эта функция создает контекст от родительского с определенным таймаутом.
```go
ctx, cancel := context.WithTimeout(context.Background(), 15 * time.Second)
defer cancel()
```
Конструкция defer cancel() гарантирует, что после выхода из функции или горутины контекст будёт отменён, и таким образом вы избежите утекания горутины — явления, когда горутина продолжает выполняться и существовать в памяти, но результат её работы больше никого не интересует.

_Если переопределить таймаут на больший отмена контекста все равно наступит через 10 секунд:_
```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    doWork(ctx)
}

func doWork(ctx context.Context) {
    newCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
}
```


#### context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)
Возвращает копию родителя с новым каналом Done.
Канал Done возвращенного контекста закрывается, когда вызывается возвращенная функция отмены или когда закрывается канал Done родительского контекста, в зависимости от того, что произойдет раньше.

