# Проблема оптимизация долгих запросов

Стратегии:

## Шаг 0. Профилирование и мониторинг
Если мы не фрики и нам жалко время, то в первую очередь идем смотреть логи/бенчмарки/мониторинг/профилируем запрос.

Чаще всего речь идет о PostgresSQL. Так что разбираем на примере ее.

- `Логи`. PostgreSQL пишет множество событий в свои логи, включая сообщения об ошибках, медленных запросах и других важных событиях (Настройте logging в postgresql.conf)
- `Профилирование`. Чаще всего речь идет о PostgresSQL. Так что на примере этой бд сделаем профилирование через `EXPLAIN ANALYZE`.
Или заиспользуем расширение `auto_explain`.
- `Мониторинг`. Обычно используют специальные сервисы мониторинга Prometheus, Grafana. Но иногда что-то простое, например внутреннее расширение `pg_stat_statements, pg_top`.

## Шаг 1.  Оптимизация структуры данных
- Сосредоточена на том, как данные организованы и хранятся, для минимизации времени доступа и поиска. В зависимости от природы данных и типа операций выбираем подход.

1. Нормализация данных
    - если хотим уменьшить дублирование данных
2. Денормализация данных
    - если хотим уменьшить число join-ов, тем самым ускорив чтение данных
3. Хранить данные в сжатом виде (erasure codec)

## 2.  Оптимизация запросов
- Нацелена на улучшение самих запросов, чтобы они выполнялись быстрее.
0. Всегда юзаем `EXPLAIN`
1. Индексы
    - в случае если чтение происходит чаще чем запись
2. Заменить подзапросы на JOIN-ы
    - join-ы лучше работают с индексами
    - join-ы меньше сканируют таблицы
    - планировщик join-ов оптимизирован явно лучше чем ваш ручной запрос (hash join, nested loop join, merge join)
    - подзапросы создают временные таблицы
3. Заменить join-ы на подзапросы
    - Очень сложные запросы с множеством JOIN (особенно outer joins)
    - Если коррелированный подзапрос используется для получения только одной строки (например, с LIMIT 1), он может быть выполнен очень быстро.
    - Подзапросы с IN или EXISTS иногда работают лучше
    - Иногда на неиндексированных столбцах join-ы работают хуже
4. Оптимизировать запросы с помощью LIMIT и Where.
5. Избегаем проблемы N+1
    - Ситуация, когда для получения данных из связанных таблиц делается N+1 запрос к БД, где N - это количество элементов в первой таблице.
    - Решается Join-ам или lazy loading/eager loading в ORM.

## 3.  Масштабирование и распределение
- Использование горизонтального или вертикального масштабирования для распределения нагрузки.

1. Горизонтальный рост бд
    - делаем больше подов, увеличиваем число кластеров
2. Вертикальный рост бд
    - наливаем больше железа
3. Партицирование данных или шардирование
    - делим базу данных на несколько частей с равномерной нагрузкой

## 4. Кэширование
- Временное хранение результатов запросов для ускорения доступа к данным.
    - Использование встроенного кеша СУБД
    - Временное хранение результатов запросов в памяти приложения
    - Использовать сервис-хранилище кешируемых запросов

